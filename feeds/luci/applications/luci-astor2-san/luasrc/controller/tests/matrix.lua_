--[[
  aStor2 -- storage area network configurable via Web-interface
  Copyright (C) 2009-2012 ETegro Technologies, PLC
                          Sergey Matveev <stargrave@stargrave.org>
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

require( "luaunit" )
common = require( "astor2.common" )
lvm = require( "astor2.lvm" )
einarc = require( "astor2.einarc" )
matrix = require( "matrix" )

local ACCESS_PATTERNS = {
	{
		name = "foobaz1",
		section_name = "foobar1",
		targetdriver = "iscsi",
		enabled = true,
		readonly = false,
		lun = 1
	},
	{
		name = "foobaz2",
		section_name = "foobar2",
		targetdriver = "iscsi",
		enabled = true,
		readonly = false,
		lun = 2
	},
	{
		name = "foobar3",
		section_name = "foobar3",
		targetdriver = "iscsi",
		enabled = true,
		readonly = false,
		lun = 3
	},
	{
		name = "foobar4",
		section_name = "foobar4",
		targetdriver = "iscsi",
		enabled = true,
		readonly = false,
		lun = 4
	},
	{
		name = "foobar5",
		section_name = "foobar5",
		targetdriver = "iscsi",
		enabled = true,
		readonly = false,
		lun = 5
	}
}

local SESSIONS = {
		["foobar3"] = {
				["iqn.deadbeef"] = scst.Session:new( {
					name = "iqn.deadbeef",
					initiator_name = "iqn.deadbeef",
					sid = "666",
					target_iqn = "iqn.OpenSAN:1",
					targetdriver = "iscsi"
				} ),
				["iqn.deadbeef_1"] = scst.Session:new( {
					name = "iqn.deadbeef_1",
					initiator_name = "iqn.deadbeef",
					sid = "667",
					target_iqn = "iqn.OpenSAN:1",
					targetdriver = "iscsi"
				} )
		},
		["foobar1"] = {
				["iqn.deadbeef"] = scst.Session:new( {
					name = "iqn.deadbeef",
					initiator_name = "iqn.deadbeef",
					sid = "668",
					target_iqn = "iqn.OpenSAN:2",
					targetdriver = "iscsi"
				} )
		}
}

local PHYSICALS_TRIPLE = {
	["3:1"] = {
		id = "3:1",
		model = "model1",
		revision = "qwerty",
		serial = "010001111",
		size = 666,
		state = "9"
	},
	["3:2"] = {
		id = "3:2",
		model = "model1",
		revision = "qwerty",
		serial = "010001112",
		size = 666,
		state = "9"
	}
}

local LOGICALS_TRIPLE = {
	[9] = {
		id = 9,
		level = "1",
		physicals = {
			["3:1"] = "9",
			["3:2"] = "9"
		},
		capacity = 666.0,
		device = "/dev/md3",
		state = "normal",
		logical_volumes = {
			["foo"] = lvm.LogicalVolume:new( {
				name = "foo",
				device = "foo",
				volume_group = {}, -- It is dummy
				size = 12
			} ),
			["bar"] = lvm.LogicalVolume:new( {
				name = "bar",
				device = "bar",
				volume_group = {}, -- It is dummy
				size = 23
			} ),
			["baz"] = lvm.LogicalVolume:new( {
				name = "baz",
				device = "baz",
				volume_group = {}, -- It is dummy
				size = 34
			} )
		}
	}
}

local PHYSICALS_DOUBLE = {
	["3:1"] = {
		id = "3:1",
		model = "model1",
		revision = "qwerty",
		serial = "010001111",
		size = 666,
		state = "3"
	},
	["3:2"] = {
		id = "3:2",
		model = "model1",
		revision = "qwerty",
		serial = "010001112",
		size = 666,
		state = "3"
	},
	["13:1"] = {
		id = "13:1",
		model = "model2",
		revision = "asdfgh",
		serial = "010001121",
		size = 333,
		state = "13"
	},
	["13:2"] = {
		id = "13:2",
		model = "model2",
		revision = "asdfgh",
		serial = "010001122",
		size = 333,
		state = "13"
	},
	["13:3"] = {
		id = "13:3",
		model = "model2",
		revision = "asdfgh",
		serial = "010001123",
		size = 333,
		state = "13"
	},
	["13:4"] = {
		id = "13:4",
		model = "model2",
		revision = "asdfgh",
		serial = "010001124",
		size = 333,
		state = "failed"
	},
	["13:5"] = {
		id = "13:5",
		model = "model2",
		revision = "asdfgh",
		serial = "010001125",
		size = 333,
		state = "hotspare"
	}
}

local LOGICALS_DOUBLE = {
	[3] = {
		id = 3,
		level = "1",
		physicals = {
			["3:1"] = "3",
			["3:2"] = "3"
		},
		capacity = 666.0,
		device = "/dev/md3",
		state = "normal"
	},
	[13] = {
		id = 13,
		level = "5",
		physicals = {
			["13:1"] = "13",
			["13:2"] = "13",
			["13:3"] = "13",
			["13:4"] = "failed",
			["13:5"] = "hotspare"
		},
		capacity = 666.0,
		device = "/dev/md13",
		state = "degraded",
		progress = 66.6
	}
}

local PHYSICALS_WITH_FREE = {
	["3:1"] = {
		id = "3:1",
		model = "model1",
		revision = "qwerty",
		serial = "010001111",
		size = 666,
		state = "0"
	},
	["3:2"] = {
		id = "3:2",
		model = "model1",
		revision = "qwerty",
		serial = "010001112",
		size = 666,
		state = "free"
	}
}

local LOGICALS_WITH_FREE = {
	[0] = {
		id = 0,
		level = "linear",
		physicals = {
			["3:1"] = "0",
		},
		capacity = 666.0,
		device = "/dev/md0",
		state = "normal"
	}
}

local LOGICALS_WITH_SNAPSHOTS = {
	[0] = {
		id = 0,
		level = "linear",
		physicals = {
			["3:1"] = "0",
		},
		logical_volumes = {
			["foo"] = lvm.LogicalVolume:new( {
				name = "foo",
				device = "foobar1",
				volume_group = {}, -- It is dummy
				size = 12,
				snapshots = {
					lvm.Snapshot:new( {
						name = "foo_2011-06-13_13-13-13",
						device = "foobar1",
						volume_group = {}, -- It is dummy
						size = 12,
						allocated = 6,
						logical_volume = "foo"
					} ),
					lvm.Snapshot:new( {
						name = "foo_2011-02-26_13-13-26",
						device = "foobar1",
						volume_group = {}, -- It is dummy
						size = 12,
						allocated = 6,
						logical_volume = "foo"
					} )
				}
			} ),
			["foo_2011-06-13_13-13-13"] = lvm.Snapshot:new( {
				name = "foo_2011-06-13_13-13-13",
				device = "foobar1",
				volume_group = {}, -- It is dummy
				size = 12,
				allocated = 6,
				logical_volume = "foo"
			} ),
			["foo_2011-02-26_13-13-26"] = lvm.Snapshot:new( {
				name = "foo_2011-02-26_13-13-26",
				device = "foobar1",
				volume_group = {}, -- It is dummy
				size = 12,
				allocated = 6,
				logical_volume = "foo"
			} )
		},
		capacity = 666.0,
		device = "/dev/md0",
		state = "normal"
	}
}

TestMatrix = {}
	function TestMatrix:setUp()
		self.access_patterns = common.deepcopy( ACCESS_PATTERNS )
		self.physicals_triple = common.deepcopy( PHYSICALS_TRIPLE )
		self.logicals_triple = common.deepcopy( LOGICALS_TRIPLE )
		self.physicals_double = common.deepcopy( PHYSICALS_DOUBLE )
		self.logicals_double = common.deepcopy( LOGICALS_DOUBLE )
		self.physicals_with_free = common.deepcopy( PHYSICALS_WITH_FREE )
		self.logicals_with_free = common.deepcopy( LOGICALS_WITH_FREE )
		self.logicals_with_snapshots = common.deepcopy( LOGICALS_WITH_SNAPSHOTS )
		self.sessions = common.deepcopy( SESSIONS )
	end
	function TestMatrix:test_matrix_double()
		local needed = {
			{
				physical = {
					rowspan = 1,
					highlight = {
						left = true,
						top = true,
						right = false,
						bottom = false
					},
					id = "3:1",
					model = "model1",
					revision = "qwerty",
					serial = "010001111",
					size = 666,
					state = "allocated"
				},
				logical = {
					rowspan = 2,
					highlight = {
						left = false,
						top = true,
						right = true,
						bottom = true
					},
					id = 3,
					level = "1",
					physicals = {
						["3:1"] = {
							rowspan = 1,
							highlight = {
								left = true,
								top = true,
								right = false,
								bottom = false
							},
							id = "3:1",
							model = "model1",
							revision = "qwerty",
							serial = "010001111",
							size = 666,
							state = "allocated"
						},
						["3:2"] = {
							rowspan = 1,
							highlight = {
								left = true,
								top = false,
								right = false,
								bottom = true
							},
							id = "3:2",
							model = "model1",
							revision = "qwerty",
							serial = "010001112",
							size = 666,
							state = "allocated"
						}
					},
					capacity = 666.0,
					device = "/dev/md3",
					state = "normal"
				}
			},
			{
				physical = {
					rowspan = 1,
					highlight = {
						left = true,
						top = false,
						right = false,
						bottom = true
					},
					id = "3:2",
					model = "model1",
					revision = "qwerty",
					serial = "010001112",
					size = 666,
					state = "allocated"
				}
			},
			{
				physical = {
					rowspan = 1,
					highlight = {
						left = true,
						top = true,
						right = false,
						bottom = false
					},
					id = "13:1",
					model = "model2",
					revision = "asdfgh",
					serial = "010001121",
					size = 333,
					state = "allocated"
				},
				logical = {
					rowspan = 5,
					highlight = {
						left = false,
						top = true,
						right = true,
						bottom = true
					},
					id = 13,
					level = "5",
					physicals = {
						["13:1"] = {
							rowspan = 1,
							highlight = {
								left = true,
								top = true,
								right = false,
								bottom = false
							},
							id = "13:1",
							model = "model2",
							revision = "asdfgh",
							serial = "010001121",
							size = 333,
							state = "allocated"
						},
						["13:2"] = {
							rowspan = 1,
							highlight = {
								left = true,
								top = false,
								right = false,
								bottom = false
							},
							id = "13:2",
							model = "model2",
							revision = "asdfgh",
							serial = "010001122",
							size = 333,
							state = "allocated"
						},
						["13:3"] = {
							rowspan = 1,
							highlight = {
								left = true,
								top = false,
								right = false,
								bottom = false
							},
							id = "13:3",
							model = "model2",
							revision = "asdfgh",
							serial = "010001123",
							size = 333,
							state = "allocated"
						},
						["13:4"] = {
							rowspan = 1,
							highlight = {
								left = true,
								top = false,
								right = false,
								bottom = false
							},
							id = "13:4",
							model = "model2",
							revision = "asdfgh",
							serial = "010001124",
							size = 333,
							state = "failed"
						},
						["13:5"] = {
							rowspan = 1,
							highlight = {
								left = true,
								top = false,
								right = false,
								bottom = true
							},
							id = "13:5",
							model = "model2",
							revision = "asdfgh",
							serial = "010001125",
							size = 333,
							state = "hotspare"
						}
					},
					capacity = 666.0,
					device = "/dev/md13",
					state = "degraded",
					progress = 66.6
				}
			},
			{
				physical = {
					rowspan = 1,
					highlight = {
						left = true,
						top = false,
						right = false,
						bottom = false
					},
					id = "13:2",
					model = "model2",
					revision = "asdfgh",
					serial = "010001122",
					size = 333,
					state = "allocated"
				},
			},
			{
				physical = {
					rowspan = 1,
					highlight = {
						left = true,
						top = false,
						right = false,
						bottom = false
					},
					id = "13:3",
					model = "model2",
					revision = "asdfgh",
					serial = "010001123",
					size = 333,
					state = "allocated"
				},
			},
			{
				physical = {
					rowspan = 1,
					highlight = {
						left = true,
						top = false,
						right = false,
						bottom = false
					},
					id = "13:4",
					model = "model2",
					revision = "asdfgh",
					serial = "010001124",
					size = 333,
					state = "failed"
				},
			},
			{
				physical = {
					rowspan = 1,
					highlight = {
						left = true,
						top = false,
						right = false,
						bottom = true
					},
					id = "13:5",
					model = "model2",
					revision = "asdfgh",
					serial = "010001125",
					size = 333,
					state = "hotspare"
				}
			}
		}

		assert( common.compare_tables(
				matrix.filter_borders_highlight( {
					lines = matrix.overall( {
						physicals = self.physicals_double, -- actually should be astor2.einarc.etc
						logicals = self.logicals_double,   -- actually should be astor2.einarc.etc
					} )
				} )[ "lines" ],
				needed
			)
		)
	end
	function TestMatrix:test_matrix_double_sorted()
		local physicals = {
			["0:1"] = {
				id = "0:1",
				model = "model2",
				revision = "asdfgh",
				serial = "010001121",
				size = 333,
				state = "0"
			},
			["0:2"] = {
				id = "0:2",
				model = "model2",
				revision = "asdfgh",
				serial = "010001122",
				size = 333,
				state = "1"
			},
			["0:3"] = {
				id = "0:3",
				model = "model2",
				revision = "asdfgh",
				serial = "010001123",
				size = 333,
				state = "2"
			}
		}
		local logicals = {
			[0] = {
				id = 0,
				level = "linear",
				physicals = {
					["0:1"] = "0",
				},
				capacity = 333.0,
				device = "/dev/md0",
				state = "normal"
			},
			[1] = {
				id = 1,
				level = "linear",
				physicals = {
					["0:2"] = "1",
				},
				capacity = 333.0,
				device = "/dev/md1",
				state = "normal"
			},
			[2] = {
				id = 2,
				level = "linear",
				physicals = {
					["0:3"] = "2",
				},
				capacity = 333.0,
				device = "/dev/md2",
				state = "normal"
			}
		}
		local needed = {
			{
				physical = {
					rowspan = 1,
					id = "0:1",
					model = "model2",
					revision = "asdfgh",
					serial = "010001121",
					size = 333,
					state = "allocated"
				},
				logical = {
					rowspan = 1,
					id = 0,
					level = "linear",
					physicals = {
						["0:1"] = {
							rowspan = 1,
							id = "0:1",
							model = "model2",
							revision = "asdfgh",
							serial = "010001121",
							size = 333,
							state = "allocated"
						}
					},
					capacity = 333.0,
					device = "/dev/md0",
					state = "normal"
				}
			},
			{
				physical = {
					rowspan = 1,
					id = "0:2",
					model = "model2",
					revision = "asdfgh",
					serial = "010001122",
					size = 333,
					state = "allocated"
				},
				logical = {
					rowspan = 1,
					id = 1,
					level = "linear",
					physicals = {
						["0:2"] = {
							rowspan = 1,
							id = "0:2",
							model = "model2",
							revision = "asdfgh",
							serial = "010001122",
							size = 333,
							state = "allocated"
						}
					},
					capacity = 333.0,
					device = "/dev/md1",
					state = "normal"
				}
			},
			{
				physical = {
					rowspan = 1,
					id = "0:3",
					model = "model2",
					revision = "asdfgh",
					serial = "010001123",
					size = 333,
					state = "allocated"
				},
				logical = {
					rowspan = 1,
					id = 2,
					level = "linear",
					physicals = {
						["0:3"] = {
							rowspan = 1,
							id = "0:3",
							model = "model2",
							revision = "asdfgh",
							serial = "010001123",
							size = 333,
							state = "allocated"
						}
					},
					capacity = 333.0,
					device = "/dev/md2",
					state = "normal"
				}
			},
		}

		assert( common.compare_tables(
				matrix.overall( {
					physicals = physicals,
					logicals = logicals,
				} ),
				needed
			)
		)
	end
	function TestMatrix:test_matrix_triple()
		local needed = {
			-- 1
			{
				physical = {
					rowspan = 3,
					highlight = {
						left = true,
						top = true,
						right = false,
						bottom = false
					},
					id = "3:1",
					model = "model1",
					revision = "qwerty",
					serial = "010001111",
					size = 666,
					state = "allocated"
				},
				logical = {
					rowspan = 6,
					highlight = {
						left = false,
						top = true,
						right = false,
						bottom = true
					},
					id = 9,
					level = "1",
					physicals = {
						["3:1"] = {
							rowspan = 3,
							highlight = {
								left = true,
								top = true,
								right = false,
								bottom = false
							},
							id = "3:1",
							model = "model1",
							revision = "qwerty",
							serial = "010001111",
							size = 666,
							state = "allocated"
						},
						["3:2"] = {
							rowspan = 3,
							highlight = {
								left = true,
								top = false,
								right = false,
								bottom = true
							},
							id = "3:2",
							model = "model1",
							revision = "qwerty",
							serial = "010001112",
							size = 666,
							state = "allocated"
						}
					},
					logical_volumes = {
						["foo"] = {
							rowspan = 2,
							highlight = {
								left = false,
								top = false,
								right = true,
								bottom = true
							},
							name = "foo",
							device = "foo",
							volume_group = {},
							snapshots = {},
							size = 12
						},
						["bar"] = {
							rowspan = 2,
							highlight = {
								left = false,
								top = true,
								right = true,
								bottom = false
							},
							name = "bar",
							device = "bar",
							volume_group = {},
							snapshots = {},
							size = 23
						},
						["baz"] = {
							rowspan = 2,
							highlight = {
								left = false,
								top = false,
								right = true,
								bottom = false
							},
							name = "baz",
							device = "baz",
							volume_group = {},
							snapshots = {},
							size = 34
						}
					},
					capacity = 666.0,
					device = "/dev/md3",
					state = "normal"
				},
				logical_volume = {
					rowspan = 2,
					highlight = {
						left = false,
						top = true,
						right = true,
						bottom = false
					},
					name = "bar",
					device = "bar",
					volume_group = {},
					snapshots = {},
					size = 23
				}
			},
			-- 2
			{
			},
			-- 3
			{
				logical_volume = {
					rowspan = 2,
					highlight = {
						left = false,
						top = false,
						right = true,
						bottom = false
					},
					name = "baz",
					device = "baz",
					volume_group = {},
					snapshots = {},
					size = 34
				}
			},
			-- 4
			{
				physical = {
					rowspan = 3,
					highlight = {
						left = true,
						top = false,
						right = false,
						bottom = true
					},
					id = "3:2",
					model = "model1",
					revision = "qwerty",
					serial = "010001112",
					size = 666,
					state = "allocated"
				}
			},
			-- 5
			{
				logical_volume = {
					rowspan = 2,
					highlight = {
						left = false,
						top = false,
						right = true,
						bottom = true
					},
					name = "foo",
					device = "foo",
					volume_group = {},
					snapshots = {},
					size = 12
				}
			},
			-- 6
			{
			}
		}

		assert( common.compare_tables(
				matrix.filter_borders_highlight( {
					lines = matrix.overall( {
						physicals = self.physicals_triple,
						logicals = self.logicals_triple
					} )
				} )[ "lines" ],
				needed
			)
		)
	end
	function TestMatrix:test_matrix_with_free_drives()
		local needed = {
			{
				physical = {
					rowspan = 1,
					highlight = {
						left = true,
						top = true,
						right = false,
						bottom = true
					},
					id = "3:1",
					model = "model1",
					revision = "qwerty",
					serial = "010001111",
					size = 666,
					state = "allocated"
				},
				logical = {
					rowspan = 1,
					highlight = {
						left = false,
						top = true,
						right = true,
						bottom = true
					},
					id = 0,
					level = "linear",
					physicals = {
						["3:1"] = {
							rowspan = 1,
							highlight = {
								left = true,
								top = true,
								right = false,
								bottom = true
							},
							id = "3:1",
							model = "model1",
							revision = "qwerty",
							serial = "010001111",
							size = 666,
							state = "allocated"
						}
					},
					capacity = 666.0,
					device = "/dev/md0",
					state = "normal"
				}
			},
			{
				physical = {
					rowspan = 1,
					highlight = {
						left = false,
						top = false,
						right = false,
						bottom = false
					},
					id = "3:2",
					model = "model1",
					revision = "qwerty",
					serial = "010001112",
					size = 666,
					state = "free"
				}
			}
		}
		assert( common.compare_tables(
				matrix.filter_borders_highlight( {
					lines = matrix.overall( {
						physicals = self.physicals_with_free,
						logicals = self.logicals_with_free
					} )
				} )[ "lines" ],
				needed
			)
		)
	end
	function TestMatrix:test_matrix_with_snapshots()
		local physicals = {
			["3:1"] = {
				id = "3:1",
				model = "model1",
				revision = "qwerty",
				serial = "010001111",
				size = 666,
				state = "0"
			}
		}
		local needed = {
			{
				physical = {
					rowspan = 3,
					id = "3:1",
					model = "model1",
					revision = "qwerty",
					serial = "010001111",
					size = 666,
					state = "allocated"
				},
				logical = {
					rowspan = 3,
					id = 0,
					level = "linear",
					physicals = {
						["3:1"] = {
							rowspan = 3,
							id = "3:1",
							model = "model1",
							revision = "qwerty",
							serial = "010001111",
							size = 666,
							state = "allocated"
						}
					},
					logical_volumes = {
						["foo"] = {
							rowspan = 1,
							name = "foo",
							device = "foobar1",
							volume_group = {},
							snapshots = {
								{
									name = "foo_2011-06-13_13-13-13",
									device = "foobar1",
									volume_group = {},
									size = 12,
									allocated = 6,
									logical_volume = "foo"
								},
								{
									name = "foo_2011-02-26_13-13-26",
									device = "foobar1",
									volume_group = {},
									size = 12,
									allocated = 6,
									logical_volume = "foo"
								}
							},
							size = 12
						},
						["foo_2011-06-13_13-13-13"] = {
							rowspan = 1,
							name = "foo_2011-06-13_13-13-13",
							device = "foobar1",
							volume_group = {},
							size = 12,
							allocated = 6,
							logical_volume = "foo"
						},
						["foo_2011-02-26_13-13-26"] = {
							rowspan = 1,
							name = "foo_2011-02-26_13-13-26",
							device = "foobar1",
							volume_group = {},
							size = 12,
							allocated = 6,
							logical_volume = "foo"
						}
					},
					capacity = 666.0,
					device = "/dev/md0",
					state = "normal"
				},
				logical_volume = {
					rowspan = 1,
					name = "foo",
					device = "foobar1",
					volume_group = {},
					snapshots = {
						{
							name = "foo_2011-06-13_13-13-13",
							device = "foobar1",
							volume_group = {},
							size = 12,
							allocated = 6,
							logical_volume = "foo"
						},
						{
							name = "foo_2011-02-26_13-13-26",
							device = "foobar1",
							volume_group = {},
							size = 12,
							allocated = 6,
							logical_volume = "foo"
						}
					},
					size = 12
				}
			},
			{
				logical_volume = {
					rowspan = 1,
					name = "foo_2011-02-26_13-13-26",
					device = "foobar1",
					volume_group = {},
					size = 12,
					allocated = 6,
					logical_volume = "foo"
				}
			},
			{
				logical_volume = {
					rowspan = 1,
					name = "foo_2011-06-13_13-13-13",
					device = "foobar1",
					volume_group = {},
					size = 12,
					allocated = 6,
					logical_volume = "foo"
				}
			}
		}
		assert( common.compare_tables(
				matrix.overall( {
					physicals = physicals,
					logicals = self.logicals_with_snapshots
				} ),
				needed
			)
		)
	end

	function TestMatrix:test_matrix_lvm10_sorting_problem()
		local physicals = {
			["3:1"] = {
				id = "3:1",
				model = "model1",
				revision = "qwerty",
				serial = "010001111",
				size = 666,
				state = "0"
			}
		}
		local logicals = {
			[0] = {
				id = 0,
				level = "linear",
				physicals = {
					["3:1"] = "0",
				},
				logical_volumes = {
					["foo"] = lvm.LogicalVolume:new( {
						name = "foo",
						device = "foobar1",
						volume_group = {}, -- It is dummy
						size = 12,
						snapshots = {
							lvm.Snapshot:new( {
								name = "foo_2011-06-13_13-13-13",
								device = "foobar1",
								volume_group = {}, -- It is dummy
								size = 12,
								allocated = 6,
								logical_volume = "foo"
							} )
						}
					} ),
					["foo10"] = lvm.LogicalVolume:new( {
						name = "foo10",
						device = "foobar1",
						volume_group = {}, -- It is dummy
						size = 12,
						snapshots = {}
					} ),
					["foo_2011-06-13_13-13-13"] = lvm.Snapshot:new( {
						name = "foo_2011-06-13_13-13-13",
						device = "foobar1",
						volume_group = {}, -- It is dummy
						size = 12,
						allocated = 6,
						logical_volume = "foo"
					} )
				},
				capacity = 666.0,
				device = "/dev/md0",
				state = "normal"
			}
		}
		local got = matrix.overall( {
			physicals = physicals,
			logicals = logicals
		} )

		assertEquals( got[1].logical_volume.name, "foo" )
		assertEquals( got[2].logical_volume.name, "foo_2011-06-13_13-13-13" )
		assertEquals( got[3].logical_volume.name, "foo10" )
	end

	function TestMatrix:test_with_access_patterns_single()
		-- Bind three first access patterns to logical volumes
		self.access_patterns[1].filename = self.logicals_triple[9].logical_volumes["bar"].device
		self.access_patterns[2].filename = self.logicals_triple[9].logical_volumes["baz"].device
		self.access_patterns[3].filename = self.logicals_triple[9].logical_volumes["foo"].device
		local needed = {
			-- 1
			{
				physical = {
					rowspan = 3,
					id = "3:1",
					model = "model1",
					revision = "qwerty",
					serial = "010001111",
					size = 666,
					state = "allocated"
				},
				logical = {
					rowspan = 6,
					id = 9,
					level = "1",
					physicals = {
						["3:1"] = {
							rowspan = 3,
							id = "3:1",
							model = "model1",
							revision = "qwerty",
							serial = "010001111",
							size = 666,
							state = "allocated"
						},
						["3:2"] = {
							rowspan = 3,
							id = "3:2",
							model = "model1",
							revision = "qwerty",
							serial = "010001112",
							size = 666,
							state = "allocated"
						}
					},
					logical_volumes = {
						["foo"] = {
							rowspan = 2,
							name = "foo",
							device = "foo",
							volume_group = {},
							snapshots = {},
							size = 12,
							access_patterns = {
								["foobar3"] = {
									name = "foobar3",
									section_name = "foobar3",
									targetdriver = "iscsi",
									enabled = true,
									readonly = false,
									filename = "foo",
									rowspan = 2,
									lun = 3
								}
							}
						},
						["bar"] = {
							rowspan = 2,
							name = "bar",
							device = "bar",
							volume_group = {},
							snapshots = {},
							size = 23,
							access_patterns = {
								["foobaz1"] = {
									name = "foobaz1",
									section_name = "foobar1",
									targetdriver = "iscsi",
									enabled = true,
									readonly = false,
									filename = "bar",
									rowspan = 2,
									lun = 1
								}
							}
						},
						["baz"] = {
							rowspan = 2,
							name = "baz",
							device = "baz",
							volume_group = {},
							snapshots = {},
							size = 34,
							access_patterns = {
								["foobaz2"] = {
									name = "foobaz2",
									section_name = "foobar2",
									targetdriver = "iscsi",
									enabled = true,
									readonly = false,
									filename = "baz",
									rowspan = 2,
									lun = 2
								}
							}
						}
					},
					capacity = 666.0,
					device = "/dev/md3",
					state = "normal"
				},
				logical_volume = {
					rowspan = 2,
					name = "bar",
					device = "bar",
					volume_group = {},
					snapshots = {},
					size = 23,
					access_patterns = {
						["foobaz1"] = {
							name = "foobaz1",
							section_name = "foobar1",
							targetdriver = "iscsi",
							enabled = true,
							readonly = false,
							filename = "bar",
							rowspan = 2,
							lun = 1
						}
					}
				},
				access_pattern = {
					name = "foobaz1",
					section_name = "foobar1",
					targetdriver = "iscsi",
					enabled = true,
					readonly = false,
					filename = "bar",
					rowspan = 2,
					lun = 1
				}
			},
			-- 2
			{
			},
			-- 3
			{
				logical_volume = {
					rowspan = 2,
					name = "baz",
					device = "baz",
					volume_group = {},
					snapshots = {},
					size = 34,
					access_patterns = {
						["foobaz2"] = {
							name = "foobaz2",
							section_name = "foobar2",
							targetdriver = "iscsi",
							enabled = true,
							readonly = false,
							filename = "baz",
							rowspan = 2,
							lun = 2
						}
					}
				},
				access_pattern = {
					name = "foobaz2",
					section_name = "foobar2",
					targetdriver = "iscsi",
					enabled = true,
					readonly = false,
					filename = "baz",
					rowspan = 2,
					lun = 2
				}
			},
			-- 4
			{
				physical = {
					rowspan = 3,
					id = "3:2",
					model = "model1",
					revision = "qwerty",
					serial = "010001112",
					size = 666,
					state = "allocated"
				}
			},
			-- 5
			{
				logical_volume = {
					rowspan = 2,
					name = "foo",
					device = "foo",
					volume_group = {},
					snapshots = {},
					size = 12,
					access_patterns = {
						["foobar3"] = {
							name = "foobar3",
							section_name = "foobar3",
							targetdriver = "iscsi",
							enabled = true,
							readonly = false,
							filename = "foo",
							rowspan = 2,
							lun = 3
						}
					}
				},
				access_pattern = {
					name = "foobar3",
					section_name = "foobar3",
					targetdriver = "iscsi",
					enabled = true,
					readonly = false,
					filename = "foo",
					rowspan = 2,
					lun = 3
				}
			},
			-- 6
			{
			},
			-- 7
			{
				access_pattern = {
					name = "foobar4",
					section_name = "foobar4",
					targetdriver = "iscsi",
					enabled = true,
					readonly = false,
					colspan = 3,
					rowspan = 1,
					lun = 4
				}
			},
			-- 8
			{
				access_pattern = {
					name = "foobar5",
					section_name = "foobar5",
					targetdriver = "iscsi",
					enabled = true,
					readonly = false,
					colspan = 3,
					rowspan = 1,
					lun = 5
				}
			}
		}

		assert( common.compare_tables(
				matrix.overall( {
					physicals = self.physicals_triple,
					logicals = self.logicals_triple,
					access_patterns = self.access_patterns
				} ),
				needed
			)
		)
	end

	function TestMatrix:test_with_access_patterns_single_with_highlight()
		self.access_patterns[1].filename = self.logicals_triple[9].logical_volumes["bar"].device
		self.access_patterns[2].filename = self.logicals_triple[9].logical_volumes["baz"].device
		self.access_patterns[3].filename = self.logicals_triple[9].logical_volumes["foo"].device

		local got = matrix.filter_borders_highlight( {
			lines = matrix.overall( {
				physicals = self.physicals_triple,
				logicals = self.logicals_triple,
				access_patterns = self.access_patterns
			} )
		} )[ "lines" ]
		assert( common.compare_tables( got[1].logical_volume.highlight, {
			left = false,
			top = true,
			right = false,
			bottom = false
		} ) )
		assert( common.compare_tables( got[1].access_pattern.highlight, {
			left = false,
			top = true,
			right = true,
			bottom = true
		} ) )
		assert( common.compare_tables( got[3].logical_volume.highlight, {
			left = false,
			top = false,
			right = false,
			bottom = false
		} ) )
		assert( common.compare_tables( got[3].access_pattern.highlight, {
			left = false,
			top = true,
			right = true,
			bottom = true
		} ) )
		assert( common.compare_tables( got[5].logical_volume.highlight, {
			left = false,
			top = false,
			right = false,
			bottom = true
		} ) )
		assert( common.compare_tables( got[5].access_pattern.highlight, {
			left = false,
			top = true,
			right = true,
			bottom = true
		} ) )
	end

	local function preparation_access_patterns_many()
		local physicals = {}
		for i = 1, 6 do
			local physical_id = "0:" .. tonumber( i )
			physicals[ physical_id ] = einarc.Physical:new( {
				id = physical_id,
				model = "foobar",
				revision = "foobar",
				serial = "foobar",
				size = 666,
				state = "0"
			} )
		end

		local logical_id = 0
		local logicals = { [ logical_id ] = {
			id = logical_id,
			level = "1",
			capacity = 666,
			state = "normal",
			device = "/dev/md0",
			physicals = {},
			logical_volumes = {
				["lvm1"] = lvm.LogicalVolume:new( {
					name = "lvm1",
					device = "lvm1",
					volume_group = {},
					size = 123
				} ),
				["lvm2"] = lvm.LogicalVolume:new( {
					name = "lvm2",
					device = "lvm2",
					volume_group = {},
					size = 123
				} )
			}
		} }

		for physical_id, _ in pairs( physicals ) do
			logicals[ logical_id ].physicals[ physical_id ] = logical_id
		end

		return physicals, logicals, logical_id
	end

	function TestMatrix:test_with_access_patterns_many()
		local physicals, logicals, logical_id = preparation_access_patterns_many()

		self.access_patterns[1].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[2].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[3].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[4].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[5].filename = logicals[ logical_id ].logical_volumes["lvm2"].device

		local got = matrix.overall( {
			physicals = physicals,
			logicals = logicals,
			access_patterns = self.access_patterns
		} )

		assertEquals( got[1].logical.rowspan, 30 )
		assertEquals( got[1].logical_volume.rowspan, 15 )
		assertEquals( got[1].logical_volume.name, "lvm1" )
		assertEquals( got[1].physical.rowspan, 5 )
		for i = 1, 30, 5 do
			assert( got[ i ].physical )
			if i > 1 and i < 30 then
				assert( not got[ i - 1 ].physical )
				assert( not got[ i + 1 ].physical )
			end
		end
		for i = 1, 30, 15 do
			assert( got[ i ].logical_volume )
		end
		assertEquals( got[ 15 + 1 + 0 * 3 ].access_pattern.name, "foobar3" )
		assertEquals( got[ 15 + 1 + 1 * 3 ].access_pattern.name, "foobar4" )
		assertEquals( got[ 15 + 1 + 2 * 3 ].access_pattern.name, "foobar5" )
		assertEquals( got[ 15 + 1 + 3 * 3 ].access_pattern.name, "foobaz1" )
		assertEquals( got[ 15 + 1 + 4 * 3 ].access_pattern.name, "foobaz2" )
	end

	function TestMatrix:test_with_access_patterns_many_highlighting()
		local physicals, logicals, logical_id = preparation_access_patterns_many()

		self.access_patterns[1].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[2].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[3].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[4].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[5].filename = logicals[ logical_id ].logical_volumes["lvm2"].device

		local got = matrix.filter_borders_highlight( {
			lines = matrix.overall( {
				physicals = physicals,
				logicals = logicals,
				access_patterns = self.access_patterns
			} )
		} )[ "lines" ]
		assert( common.compare_tables( got[15 + 1].logical_volume.highlight, {
			left = false,
			top = false,
			right = false,
			bottom = true
		} ) )
		assert( common.compare_tables( got[15 + 1 + 0 * 3].access_pattern.highlight, {
			left = false,
			top = true,
			right = true,
			bottom = false
		} ) )
		assert( common.compare_tables( got[15 + 1 + 1 * 3].access_pattern.highlight, {
			left = false,
			top = false,
			right = true,
			bottom = false
		} ) )
		assert( common.compare_tables( got[15 + 1 + 2 * 3].access_pattern.highlight, {
			left = false,
			top = false,
			right = true,
			bottom = false
		} ) )
		assert( common.compare_tables( got[15 + 1 + 3 * 3].access_pattern.highlight, {
			left = false,
			top = false,
			right = true,
			bottom = false
		} ) )
		assert( common.compare_tables( got[15 + 1 + 4 * 3].access_pattern.highlight, {
			left = false,
			top = false,
			right = true,
			bottom = true
		} ) )
	end

	function TestMatrix:test_sessions()
		local physicals, logicals, logical_id = preparation_access_patterns_many()

		self.access_patterns[1].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[2].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[3].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[4].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[5].filename = logicals[ logical_id ].logical_volumes["lvm2"].device

		local got = matrix.overall( {
			physicals = physicals,
			logicals = logicals,
			access_patterns = self.access_patterns,
			sessions = self.sessions
		} )

		assertEquals( got[1].logical.rowspan, 60 )
		assertEquals( got[1].logical_volume.rowspan, 30 )
		assertEquals( got[1].physical.rowspan, 10 )
		for i = 1, 30*2, 5*2 do
			assert( got[ i ].physical )
		end
		for i = 1, 30*2, 15*2 do
			assert( got[ i ].logical_volume )
		end
		assertEquals( got[ 15*2 + 1 + 0 * 6 ].access_pattern.name, "foobar3" )
		assertEquals( got[ 15*2 + 1 + 1 * 6 ].access_pattern.name, "foobar4" )
		assertEquals( got[ 15*2 + 1 + 2 * 6 ].access_pattern.name, "foobar5" )
		assertEquals( got[ 15*2 + 1 + 3 * 6 ].access_pattern.name, "foobaz1" )
		assertEquals( got[ 15*2 + 1 + 4 * 6 ].access_pattern.name, "foobaz2" )

		assertEquals( got[ 15*2 + 1 + 0 * 6 + 0 * 3 ].session.name, "iqn.deadbeef" )
		assertEquals( got[ 15*2 + 1 + 0 * 6 + 0 * 3 ].session.sid, "666" )
		assertEquals( got[ 15*2 + 1 + 0 * 6 + 1 * 3 ].session.name, "iqn.deadbeef_1" )
		assertEquals( got[ 15*2 + 1 + 0 * 6 + 1 * 3 ].session.sid, "667" )
		assertEquals( got[ 15*2 + 1 + 3 * 6 + 0 * 3 ].session.name, "iqn.deadbeef" )
		assertEquals( got[ 15*2 + 1 + 3 * 6 + 0 * 3 ].session.sid, "668" )
	end

	function TestMatrix:test_sessions_highlighting()
		local physicals, logicals, logical_id = preparation_access_patterns_many()

		self.access_patterns[1].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[2].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[3].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[4].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[5].filename = logicals[ logical_id ].logical_volumes["lvm2"].device

		local got = matrix.filter_borders_highlight( {
			lines = matrix.overall( {
				physicals = physicals,
				logicals = logicals,
				access_patterns = self.access_patterns,
				sessions = self.sessions
			} )
		} )[ "lines" ]
		assert( common.compare_tables( got[15*2 + 1 + 0 * 6].access_pattern.highlight, {
			left = false,
			top = true,
			right = false,
			bottom = false
		} ) )
		assert( common.compare_tables( got[15*2 + 1 + 0 * 6 + 0 * 3].session.highlight, {
			left = false,
			top = true,
			right = true,
			bottom = false
		} ) )
		assert( common.compare_tables( got[15*2 + 1 + 0 * 6 + 1 * 3].session.highlight, {
			left = false,
			top = false,
			right = true,
			bottom = true
		} ) )
		assert( common.compare_tables( got[15*2 + 1 + 1 * 6].access_pattern.highlight, {
			left = false,
			top = false,
			right = true,
			bottom = false
		} ) )
		assert( common.compare_tables( got[15*2 + 1 + 2 * 6].access_pattern.highlight, {
			left = false,
			top = false,
			right = true,
			bottom = false
		} ) )
		assert( common.compare_tables( got[15*2 + 1 + 3 * 6].access_pattern.highlight, {
			left = false,
			top = false,
			right = false,
			bottom = false
		} ) )
		assert( common.compare_tables( got[15*2 + 1 + 3 * 6 + 0 * 3].session.highlight, {
			left = false,
			top = true,
			right = true,
			bottom = true
		} ) )
		assert( common.compare_tables( got[15*2 + 1 + 4 * 6].access_pattern.highlight, {
			left = false,
			top = false,
			right = true,
			bottom = true
		} ) )
	end

TestFilterHotspareCalculation = {}
	function TestFilterHotspareCalculation:setUp()
		self.physicals_double = common.deepcopy( PHYSICALS_DOUBLE )
		self.logicals_double = common.deepcopy( LOGICALS_DOUBLE )
	end
	function TestFilterHotspareCalculation:test_hotspare_calculation()
		-- Add several other drives that will be checked
		self.physicals_double[ "666:1" ] = {
			id = "666:1",
			model = "verysmall",
			revision = "qwerty",
			serial = "01",
			size = 133,
			state = "free"
		}
		self.physicals_double[ "666:2" ] = {
			id = "666:2",
			model = "shouldfit",
			revision = "qwerty",
			serial = "01",
			size = 333,
			state = "free"
		}
		self.physicals_double[ "666:3" ] = {
			id = "666:3",
			model = "anotherfit",
			revision = "qwerty",
			serial = "01",
			size = 444,
			state = "free"
		}
		self.physicals_double[ "666:4" ] = {
			id = "666:4",
			model = "doublefit",
			revision = "qwerty",
			serial = "01",
			size = 666,
			state = "free"
		}
		self.physicals_double[ "666:5" ] = {
			id = "666:5",
			model = "fiteverywhere",
			revision = "qwerty",
			serial = "01",
			size = 777,
			state = "free"
		}

		local got = matrix.filter_calculate_hotspares( {
			lines = matrix.overall( {
				physicals = self.physicals_double,
				logicals = self.logicals_double
			} )
		} )[ "lines" ]

		assertEquals( got[8].physical.hotspare_availability, nil ) -- 666:1
		assert( common.compare_tables( -- 666:2
				got[9].physical.hotspare_availability,
				{ 13 } ) )
		assert( common.compare_tables( -- 666:3
				got[10].physical.hotspare_availability,
				{ 13 } ) )
		assert( common.compare_tables( -- 666:4
				got[11].physical.hotspare_availability,
				{ 3, 13 } ) )
		assert( common.compare_tables( -- 666:5
				got[12].physical.hotspare_availability,
				{ 3, 13 } ) )
		-- Check minimal sizes hash
		assert( common.compare_tables( -- 666:5
				got[12].physical.hotspare_minimal_sizes,
				{ [3] = 666, [13] = 333 } ) )

		-- Try to assign hotspare to different RAID levels
		for _, level in ipairs( { "linear", "0" } ) do
			self.logicals_double[13].level = level
			got = matrix.filter_calculate_hotspares( {
				lines = matrix.overall( {
					physicals = self.physicals_double,
					logicals = self.logicals_double
				} )
			} )[ "lines" ]
			assertEquals( got[10].physical.hotspare_availability, nil ) -- 666:3
			assert( common.compare_tables( -- 666:4
					got[11].physical.hotspare_availability,
					{ 3 } ) )
		end
	end

TestFilterPercentage = {}
	function TestFilterPercentage:setUp()
		self.physicals_triple = common.deepcopy( PHYSICALS_TRIPLE )
		self.logicals_triple = common.deepcopy( LOGICALS_TRIPLE )
	end
	function TestFilterPercentage:test_volume_group_percentage_zero()
		local logicals = self.logicals_triple
		logicals[9].logical_volumes["bar"].volume_group.total = 0
		logicals[9].logical_volumes["bar"].volume_group.allocated = 100

		-- Dummy values
		logicals[9].logical_volumes["foo"].volume_group.total = 0
		logicals[9].logical_volumes["foo"].volume_group.allocated = 0
		logicals[9].logical_volumes["baz"].volume_group.total = 0
		logicals[9].logical_volumes["baz"].volume_group.allocated = 0

		local got = matrix.filter_volume_group_percentage( {
			lines = matrix.overall( {
				physicals = self.physicals_triple,
				logicals = self.logicals_triple
			} )
		} )[ "lines" ]
		assertEquals( got[1].logical_volume.volume_group.percentage, 0 )
	end
	function TestFilterPercentage:test_volume_group_percentage()
		local logicals = self.logicals_triple
		logicals[9].logical_volumes["foo"].volume_group.total = 666
		logicals[9].logical_volumes["foo"].volume_group.allocated = 123

		logicals[9].logical_volumes["bar"].volume_group.total = 100
		logicals[9].logical_volumes["bar"].volume_group.allocated = 12

		logicals[9].logical_volumes["baz"].volume_group.total = 213456
		logicals[9].logical_volumes["baz"].volume_group.allocated = 213056
		local got = matrix.filter_volume_group_percentage( {
			lines = matrix.overall( {
				physicals = self.physicals_triple,
				logicals = self.logicals_triple
			} )
		} )[ "lines" ]
		assertEquals( got[1].logical_volume.volume_group.percentage, 12 )
		assertEquals( got[3].logical_volume.volume_group.percentage, 100 )
		assertEquals( got[5].logical_volume.volume_group.percentage, 19 )
	end

TestFilterActionsAvailability = {}
	function TestFilterActionsAvailability:setUp()
		self.access_patterns = common.deepcopy( ACCESS_PATTERNS )
		self.physicals_triple = common.deepcopy( PHYSICALS_TRIPLE )
		self.logicals_triple = common.deepcopy( LOGICALS_TRIPLE )
		self.physicals_double = common.deepcopy( PHYSICALS_DOUBLE )
		self.logicals_double = common.deepcopy( LOGICALS_DOUBLE )
		self.logicals_with_snapshots = common.deepcopy( LOGICALS_WITH_SNAPSHOTS )
	end
	function TestFilterActionsAvailability:test_logical_deletability()
		assertEquals(
			matrix.filter_deletability_logical( {
				lines = matrix.overall( {
					physicals = self.physicals_double,
					logicals = self.logicals_double,
				} )
			} )["lines"][1]["logical"].deletable,
			true
		)
		assertEquals(
			matrix.filter_deletability_logical( {
				lines = matrix.overall( {
					physicals = self.physicals_triple,
					logicals = self.logicals_triple,
				} )
			} )["lines"][1]["logical"].deletable,
			false
		)
	end
	function TestFilterActionsAvailability:test_logical_volume_deletability()
		assertEquals(
			matrix.filter_deletability_logical_volume( {
				lines = matrix.overall( {
					physicals = self.physicals_triple,
					logicals = self.logicals_triple,
					access_patterns = self.access_patterns
				} )
			} )["lines"][1]["logical_volume"].deletable,
			true
		)

		self.access_patterns[1].filename = self.logicals_triple[9].logical_volumes["bar"].device
		self.access_patterns[2].filename = self.logicals_triple[9].logical_volumes["baz"].device
		self.access_patterns[3].filename = self.logicals_triple[9].logical_volumes["foo"].device

		assertEquals(
			matrix.filter_deletability_logical_volume( {
				lines = matrix.overall( {
					physicals = self.physicals_triple,
					logicals = self.logicals_triple,
					access_patterns = self.access_patterns
				} )
			} )["lines"][1]["logical_volume"].deletable,
			false
		)
	end
	function TestFilterActionsAvailability:test_logical_volume_resizability()
		assertEquals(
			matrix.filter_resizability_logical_volume( {
				lines = matrix.overall( {
					physicals = self.physicals_triple,
					logicals = self.logicals_triple,
				} )
			} )["lines"][1]["logical_volume"].resizable,
			true
		)
		assertEquals(
			matrix.filter_resizability_logical_volume( {
				lines = matrix.overall( {
					physicals = self.physicals_triple,
					logicals = self.logicals_with_snapshots,
				} )
			} )["lines"][1]["logical_volume"].resizable,
			false
		)
	end
	function TestFilterActionsAvailability:test_access_pattern_unbindability()
		self.access_patterns[1].lun = 0
		self.access_patterns[1].filename = self.logicals_triple[9].logical_volumes["bar"].device
		self.access_patterns[2].filename = self.logicals_triple[9].logical_volumes["baz"].device
		self.access_patterns[3].filename = self.logicals_triple[9].logical_volumes["foo"].device
		local got = nil

		got = matrix.filter_unbindability_access_pattern( {
			lines = matrix.overall( {
				physicals = self.physicals_triple,
				logicals = self.logicals_triple,
				access_patterns = self.access_patterns
			} )
		} )["lines"]
		assertEquals( got[1]["access_pattern"].unbindable, true )
		assertEquals( got[3]["access_pattern"].unbindable, true )
		assertEquals( got[5]["access_pattern"].unbindable, true )

		local physicals, logicals, logical_id = preparation_access_patterns_many()

		self.access_patterns[1].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[2].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[3].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[4].filename = logicals[ logical_id ].logical_volumes["lvm2"].device
		self.access_patterns[5].filename = logicals[ logical_id ].logical_volumes["lvm2"].device

		got = matrix.filter_unbindability_access_pattern( {
			lines = matrix.overall( {
				physicals = physicals,
				logicals = logicals,
				access_patterns = self.access_patterns
			} )
		} )["lines"]
		assertEquals( got[ 15 + 1 + 3 * 3 ]["access_pattern"].unbindable, false ) -- here is LUN0
		assertEquals( got[ 15 + 1 + 3 * 1 ]["access_pattern"].unbindable, true )
		assertEquals( got[ 15 + 1 + 3 * 2 ]["access_pattern"].unbindable, true )
	end
	function TestFilterActionsAvailability:test_physical_flashcache_unbindable()
		local physicals = common.deepcopy( PHYSICALS_TRIPLE )
		local logicals = common.deepcopy( LOGICALS_TRIPLE )
		local access_patterns = common.deepcopy( ACCESS_PATTERNS )

		physicals[ "3:2" ].state = "cache"
		logicals[ 9 ].cached_by = "3:2"
		logicals[ 9 ].level = "0"

		local got = matrix.filter_unbindability_physical_flashcache( {
			lines = matrix.overall( {
				physicals = physicals,
				logicals  = logicals
			} )
		} )

		for _, line in ipairs( got.lines ) do
			if ( line.physical and line.physical.id == "3:2" ) then
				assertEquals( line.physical.unbindable, true )
			end
		end

		access_patterns[1].lun = 0
		access_patterns[1].filename = logicals[9].logical_volumes["bar"].device
		access_patterns[2].filename = logicals[9].logical_volumes["baz"].device

		got = matrix.filter_unbindability_physical_flashcache( {
			lines = matrix.overall( {
				physicals = physicals,
				logicals  = logicals,
				access_patterns = access_patterns
			} )
		} )

		for _, line in ipairs( got.lines ) do
			if ( line.physical and line.physical.id == "3:2" ) then
				assertEquals( line.physical.unbindable, false )
			end
		end
	end

TestFilterAlternationBorderColors = {}
	function TestFilterAlternationBorderColors:test_colors()
		local max_logicals = 6
		local max_physicals = 3
		local max_logical_volumes = 4
		local colors_array = { "black", "blue", "green" }
		-- Generate physicals
		local physicals = {}
		for l = 0, ( max_logicals - 1 ) do
			for i = 1, max_physicals do
				local physical_id = tonumber( l ) .. ":" .. tonumber( i )
				physicals[ physical_id ] = einarc.Physical:new( {
					id = physical_id,
					model = "foobar",
					revision = "foobar",
					serial = "foobar",
					size = 666 * max_physicals,
					state = "0"
				} )
			end
		end
		-- Generate logicals
		local logicals = {}
		for l = 0, ( max_logicals - 1 ) do
			local logical_id = tonumber( l )
			logicals[ logical_id ] = {
				id = logical_id,
				level = "1",
				capacity = 666,
				state = "normal",
				device = "/dev/md0",
				physicals = {},
				logical_volumes = {
				}
			}
			--Generate logical_volumes
			local logical_volumes = {}
			for v = 1, max_logical_volumes do
				local volume_name = "lvm" .. tonumber( l ) .. tonumber( v )
				logical_volumes[ volume_name ] = lvm.LogicalVolume:new( {
					name = volume_name,
					device = "foobar" .. tonumber( v ),
					volume_group = {},
					size = 123
				} )
			end
			for volume_name,_ in pairs( logical_volumes ) do
				logicals[ logical_id ].logical_volumes[ volume_name ] = logical_volumes[ volume_name ]
			end
			-- Filling physicals in logicals
			local physicals = {}
			for i = 1, max_physicals do
				local physical_id = tonumber( l ) .. ":" .. tonumber( i )
				physicals[ physical_id ] = einarc.Physical:new( {
					id = physical_id,
					model = "foobar",
					revision = "foobar",
					serial = "foobar",
					size = 666,
					state = "0"
				} )
			end
			for physical_id,_ in pairs( physicals ) do
				logicals[ logical_id ].physicals[ physical_id ] = logical_id
			end
		end

		local got = matrix.filter_alternation_border_colors(
			matrix.filter_borders_highlight( {
				lines = matrix.overall( {
					physicals = physicals,
					logicals = logicals
				} )
			} ),
			colors_array
		)[ "lines" ]

		--print( common.ppt( { got } ) )
		local color = colors_array[ 1 ] --black
		assertEquals( got[ 1 ].logical.highlight.color, color )
		assertEquals( got[ 1 ].physical.highlight.color, color )
		assertEquals( got[ 1 ].logical_volume.highlight.color, color )
		assertEquals( got[ 4 ].logical_volume.highlight.color, color )
		assertEquals( got[ 7 ].logical_volume.highlight.color, color )
		assertEquals( got[ 10 ].logical_volume.highlight.color, color )
		local color = colors_array[ 2 ] --blue
		assertEquals( got[ 13 ].logical.highlight.color, color )
		assertEquals( got[ 13 ].physical.highlight.color, color )
		assertEquals( got[ 13 ].logical_volume.highlight.color, color )
		local color = colors_array[ 3 ] --green
		assertEquals( got[ 25 ].logical.highlight.color, color )
		assertEquals( got[ 25 ].physical.highlight.color, color )
		assertEquals( got[ 25 ].logical_volume.highlight.color, color )
		local color = colors_array[ 1 ] --black
		assertEquals( got[ 37 ].logical.highlight.color, color )
		assertEquals( got[ 37 ].physical.highlight.color, color )
		assertEquals( got[ 37 ].logical_volume.highlight.color, color )

		local color = 1
		local line = 1
		for i = 1, max_logicals do
			assertEquals( got[ line ].logical.highlight.color, colors_array[ color ] )
			assertEquals( got[ line ].physical.highlight.color, colors_array[ color ] )
			for k = 1, max_logical_volumes do
				assertEquals( got[ line ].logical_volume.highlight.color, colors_array[ color ] )
				line = line + max_logical_volumes - 1
			end
			if color == #colors_array then
				color = 1
			else
				color = color + 1
			end
		end
	end
	function TestFilterAlternationBorderColors:test_with_access_patterns()
		local max_logicals = 6
		local max_physicals = 3
		local max_logical_volumes = 4
		local max_access_patterns = 2
		local colors_array = { "black", "blue", "green" }
		-- Generate physicals
		local physicals = {}
		for l = 0, ( max_logicals - 1 ) do
			for p = 1, max_physicals do
				local physical_id = tonumber( l ) .. ":" .. tonumber( p )
				physicals[ physical_id ] = einarc.Physical:new( {
					id = physical_id,
					model = "foobar",
					revision = "foobar",
					serial = "foobar",
					size = 666 * max_physicals,
					state = "0"
				} )
			end
		end
		-- Generate logicals
		local logicals = {}
		for l = 0, ( max_logicals - 1 ) do
			local logical_id = tonumber( l )
			logicals[ logical_id ] = {
				id = logical_id,
				level = "1",
				capacity = 666,
				state = "normal",
				device = "/dev/md" .. tonumber( l ),
				physicals = {},
				logical_volumes = {
				}
			}
			--Generate logical_volumes
			local logical_volumes = {}
			for v = 1, max_logical_volumes do
				local volume_name = "lvm" .. tonumber( l ) .. tonumber( v )
				logical_volumes[ volume_name ] = lvm.LogicalVolume:new( {
					name = volume_name,
					device = "foobar" .. tonumber( v ),
					volume_group = {},
					size = 123
				} )
				--Generate access_patterns
				local access_patterns = {}
				for a = 1, max_access_patterns do
					local pattern_name = "ap-name-" .. tonumber( a )
					access_patterns[ pattern_name ] = scst.AccessPattern:new( {
						name = pattern_name,
						section_name = "foobar" .. tonumber( a ),
						targetdriver = "iscsi",
						enabled = true,
						readonly = false,
						lun = tonumber( a ) - 1
					} )
				end
				-- Filling access_patterns in logical_volumes
				logical_volumes[ volume_name ].access_patterns = {}
				for pattern_name,_ in pairs( access_patterns ) do
					access_patterns[ pattern_name ].filename = logical_volumes[ volume_name ].device
					logical_volumes[ volume_name ].access_patterns[ pattern_name ] = access_patterns[ pattern_name ]
				end
			end
			for volume_name,_ in pairs( logical_volumes ) do
				logicals[ logical_id ].logical_volumes[ volume_name ] = logical_volumes[ volume_name ]
			end
			-- Filling physicals in logicals
			local physicals = {}
			for p = 1, max_physicals do
				local physical_id = tonumber( l ) .. ":" .. tonumber( p )
				physicals[ physical_id ] = einarc.Physical:new( {
					id = physical_id,
					model = "foobar",
					revision = "foobar",
					serial = "foobar",
					size = 666,
					state = "0"
				} )
			end
			for physical_id,_ in pairs( physicals ) do
				logicals[ logical_id ].physicals[ physical_id ] = logical_id
			end
		end

		local got = matrix.filter_alternation_border_colors(
			matrix.filter_borders_highlight( {
				lines = matrix.overall( {
					physicals = physicals,
					logicals = logicals
				} )
			} ),
			colors_array
		)[ "lines" ]

		--print( common.ppt( { got } ) )
		local color = colors_array[ 1 ] --black
		assertEquals( got[ 1 ].logical.highlight.color, color )
		assertEquals( got[ 1 ].physical.highlight.color, color )
		assertEquals( got[ 1 ].logical_volume.highlight.color, color )
		assertEquals( got[ 1 ].access_pattern.highlight.color, color )
		assertEquals( got[ 4 ].logical_volume.highlight.color, color )
		assertEquals( got[ 4 ].access_pattern.highlight.color, color )
		assertEquals( got[ 7 ].logical_volume.highlight.color, color )
		assertEquals( got[ 7 ].access_pattern.highlight.color, color )
		assertEquals( got[ 10 ].logical_volume.highlight.color, color )
		assertEquals( got[ 10 ].access_pattern.highlight.color, color )
		local color = colors_array[ 2 ] --blue
		assertEquals( got[ 13 ].logical.highlight.color, color )
		assertEquals( got[ 13 ].access_pattern.highlight.color, color )
		assertEquals( got[ 13 ].physical.highlight.color, color )
		assertEquals( got[ 13 ].logical_volume.highlight.color, color )
		local color = colors_array[ 3 ] --green
		assertEquals( got[ 25 ].logical.highlight.color, color )
		assertEquals( got[ 25 ].physical.highlight.color, color )
		assertEquals( got[ 25 ].logical_volume.highlight.color, color )
		assertEquals( got[ 25 ].access_pattern.highlight.color, color )
		local color = colors_array[ 1 ] --black
		assertEquals( got[ 37 ].logical.highlight.color, color )
		assertEquals( got[ 37 ].physical.highlight.color, color )
		assertEquals( got[ 37 ].logical_volume.highlight.color, color )
		assertEquals( got[ 37 ].access_pattern.highlight.color, color )

		local color = 1
		local line = 1
		for i = 1, max_logicals do
			assertEquals( got[ line ].logical.highlight.color, colors_array[ color ] )
			assertEquals( got[ line ].physical.highlight.color, colors_array[ color ] )
			assertEquals( got[ line ].access_pattern.highlight.color, colors_array[ color ] )
			for k = 1, max_logical_volumes do
				assertEquals( got[ line ].logical_volume.highlight.color, colors_array[ color ] )
				line = line + max_logical_volumes - 1
			end
			if color == #colors_array then
				color = 1
			else
				color = color + 1
			end
		end
	end

TestFilterHighlightSnapshots = {}
	function TestFilterHighlightSnapshots:test_colors()
		local max_logicals = 1
		local max_physicals = 1
		local max_logical_volumes = 7
		local max_snapshots = 2
		local colors_array = { "normal_color", "light_color" }
		-- Generate physicals
		local physicals = {}
		for l = 0, ( max_logicals - 1 ) do
			for i = 1, max_physicals do
				local physical_id = tonumber( l ) .. ":" .. tonumber( i )
				physicals[ physical_id ] = einarc.Physical:new( {
					id = physical_id,
					model = "foobar",
					revision = "foobar",
					serial = "foobar",
					size = 666 * max_physicals,
					state = "0"
				} )
			end
		end
		-- Generate logicals
		local logicals = {}
		for l = 0, ( max_logicals - 1 ) do
			local logical_id = tonumber( l )
			logicals[ logical_id ] = {
				id = logical_id,
				level = "1",
				capacity = 666,
				state = "normal",
				device = "/dev/md0",
				physicals = {},
				logical_volumes = {
				}
			}
			-- Generate logical_volumes
			local logical_volumes = {}
			for v = 1, max_logical_volumes do
				local volume_name = "lvm" .. tonumber( l ) .. tonumber( v )
				logical_volumes[ volume_name ] = lvm.LogicalVolume:new( {
					name = volume_name,
					device = "foobar" .. tonumber( v ),
					volume_group = {},
					size = 123
				} )
				-- Generate snapshots
				local snapshots = {}
				for s = 1, max_snapshots do
					local snapshot_name = volume_name .. "_time-" .. tonumber( s )
					snapshots[ tonumber( s ) ] = lvm.Snapshot:new( {
						name = snapshot_name,
						device = "foobar" .. tonumber( v ) .. "_time-" .. tonumber( s ),
						volume_group = {},
						size = 12,
						allocated = 6,
						logical_volume = volume_name
					} )
				end
				-- Filling snapshots in logical_volumes
				logical_volumes[ volume_name ].snapshots = snapshots
				-- Filling snapshots in logicals
				for _, snapshot in ipairs( snapshots ) do
					logicals[ logical_id ].logical_volumes[ snapshot.name ] = snapshot
				end
			end
			-- Filling logical_volumes in logicals
			for volume_name,_ in pairs( logical_volumes ) do
				logicals[ logical_id ].logical_volumes[ volume_name ] = logical_volumes[ volume_name ]
			end
			-- Filling physicals in logicals
			local physicals = {}
			for i = 1, max_physicals do
				local physical_id = tonumber( l ) .. ":" .. tonumber( i )
				physicals[ physical_id ] = einarc.Physical:new( {
					id = physical_id,
					model = "foobar",
					revision = "foobar",
					serial = "foobar",
					size = 666,
					state = "0"
				} )
			end
			for physical_id,_ in pairs( physicals ) do
				logicals[ logical_id ].physicals[ physical_id ] = logical_id
			end
		end

		local got = matrix.filter_highlight_snapshots(
			matrix.filter_alternation_border_colors(
				matrix.filter_borders_highlight( {
					lines = matrix.overall( {
						physicals = physicals,
						logicals = logicals
					} )
				} ),
				colors_array
			)
		)[ "lines" ]

		--print( common.ppt( { got } ) )
		local color = 1 --normal_color
		assertEquals( got[ 1 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 2 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 3 ].logical_volume.highlight.background_color, colors_array[ color ] )

		local color = 2 --light_color
		assertEquals( got[ 4 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 5 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 6 ].logical_volume.highlight.background_color, colors_array[ color ] )

		local color = 1
		local line = 1
		for i = 1, max_logical_volumes do
			local step = 1 + max_snapshots
			for k = 1, step do
				assertEquals( got[ line ].logical_volume.highlight.background_color, colors_array[ color ] )
				line = line + max_snapshots - 1
			end
			if color == #colors_array then
				color = 1
			else
				color = color + 1
			end
		end
	end
	function TestFilterHighlightSnapshots:test_colors_with_different_numbers_of_snapshots()
		local max_logicals = 1
		local max_physicals = 1
		local max_logical_volumes = 3
		local colors_array = { "normal_color", "light_color" }
		local physicals = {}
		for l = 0, ( max_logicals - 1 ) do
			for i = 1, max_physicals do
				local physical_id = tonumber( l ) .. ":" .. tonumber( i )
				physicals[ physical_id ] = einarc.Physical:new( {
					id = physical_id,
					model = "foobar",
					revision = "foobar",
					serial = "foobar",
					size = 666 * max_physicals,
					state = "0"
				} )
			end
		end
		-- Generate logicals
		local logicals = {}
		for l = 0, ( max_logicals - 1 ) do
			local logical_id = tonumber( l )
			logicals[ logical_id ] = {
				id = logical_id,
				level = "1",
				capacity = 666,
				state = "normal",
				device = "/dev/md0",
				physicals = {},
				logical_volumes = {
				}
			}
			-- Generate logical_volumes
			local logical_volumes = {}
			for v = 1, max_logical_volumes do
				local volume_name = "lvm" .. tonumber( l ) .. tonumber( v )
				logical_volumes[ volume_name ] = lvm.LogicalVolume:new( {
					name = volume_name,
					device = "foobar" .. tonumber( v ),
					volume_group = {},
					size = 123
				} )
			end
			-- Generate snapshots
			local snapshots_for_lvm01 = {}
			for s = 1, 3 do
				local snapshot_name = "lvm01_time-" .. tonumber( s )
				snapshots_for_lvm01[ tonumber( s ) ] = lvm.Snapshot:new( {
					name = snapshot_name,
					device = "foobar0_time-" .. tonumber( s ),
					volume_group = {},
					size = 12,
					allocated = 6,
					logical_volume = "lvm01"
				} )
			end
			local snapshots_for_lvm03 = {}
			for s = 1, 2 do
				local snapshot_name = "lvm03_time-" .. tonumber( s )
				snapshots_for_lvm03[ tonumber( s ) ] = lvm.Snapshot:new( {
					name = snapshot_name,
					device = "foobar3_time-" .. tonumber( s ),
					volume_group = {},
					size = 12,
					allocated = 6,
					logical_volume = "lvm03"
				} )
			end
			-- Filling logical_volumes in logicals
			for volume_name,_ in pairs( logical_volumes ) do
				logicals[ logical_id ].logical_volumes[ volume_name ] = logical_volumes[ volume_name ]
			end
			-- Filling snapshots in logical_volumes
			logicals[ logical_id ].logical_volumes[ "lvm01" ].snapshots = snapshots_for_lvm01
			logicals[ logical_id ].logical_volumes[ "lvm03" ].snapshots = snapshots_for_lvm03
			-- Filling snapshots in logicals
			for _, snapshot in ipairs( snapshots_for_lvm01 ) do
				logicals[ logical_id ].logical_volumes[ snapshot.name ] = snapshot
			end
			for _, snapshot in ipairs( snapshots_for_lvm03 ) do
				logicals[ logical_id ].logical_volumes[ snapshot.name ] = snapshot
			end
			-- Filling physicals in logicals
			local physicals = {}
			for i = 1, max_physicals do
				local physical_id = tonumber( l ) .. ":" .. tonumber( i )
				physicals[ physical_id ] = einarc.Physical:new( {
					id = physical_id,
					model = "foobar",
					revision = "foobar",
					serial = "foobar",
					size = 666,
					state = "0"
				} )
			end
			for physical_id,_ in pairs( physicals ) do
				logicals[ logical_id ].physicals[ physical_id ] = logical_id
			end
		end

		local got = matrix.filter_highlight_snapshots(
			matrix.filter_alternation_border_colors(
				matrix.filter_borders_highlight( {
					lines = matrix.overall( {
						physicals = physicals,
						logicals = logicals
					} )
				} ),
				colors_array
			)
		)[ "lines" ]

		--print( common.ppt( { got } ) )
		local color = 1 --normal_color
		assertEquals( got[ 1 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 2 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 3 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 4 ].logical_volume.highlight.background_color, colors_array[ color ] )

		local color = 2 --light_color
		assertEquals( got[ 5 ].logical_volume.highlight.background_color, colors_array[ color ] )

		local color = 1 --normal_color
		assertEquals( got[ 6 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 7 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 8 ].logical_volume.highlight.background_color, colors_array[ color ] )
	end
	function TestFilterHighlightSnapshots:test_colors_with_different_numbers_of_logical_volumes()
		local max_logicals = 3
		local max_physicals = 1
		local max_logical_volumes = 3
		local max_snapshots = 2
		local colors_array = { "normal_color", "light_color" }
		-- Generate physicals
		local physicals = {}
		for l = 0, ( max_logicals - 1 ) do
			for i = 1, max_physicals do
				local physical_id = tonumber( l ) .. ":" .. tonumber( i )
				physicals[ physical_id ] = einarc.Physical:new( {
					id = physical_id,
					model = "foobar",
					revision = "foobar",
					serial = "foobar",
					size = 666 * max_physicals,
					state = "0"
				} )
			end
		end
		-- Generate logicals
		local logicals = {}
		for l = 0, ( max_logicals - 1 ) do
			local logical_id = tonumber( l )
			logicals[ logical_id ] = {
				id = logical_id,
				level = "1",
				capacity = 666,
				state = "normal",
				device = "/dev/md0",
				physicals = {},
				logical_volumes = {
				}
			}
			-- Generate logical_volumes
			local logical_volumes = {}
			for v = 1, max_logical_volumes do
				local volume_name = "lvm" .. tonumber( l ) .. tonumber( v )
				logical_volumes[ volume_name ] = lvm.LogicalVolume:new( {
					name = volume_name,
					device = "foobar" .. tonumber( v ),
					volume_group = {},
					size = 123
				} )
				-- Generate snapshots
				local snapshots = {}
				for s = 1, max_snapshots do
					local snapshot_name = volume_name .. "_time-" .. tonumber( s )
					snapshots[ tonumber( s ) ] = lvm.Snapshot:new( {
						name = snapshot_name,
						device = "foobar" .. tonumber( v ) .. "_time-" .. tonumber( s ),
						volume_group = {},
						size = 12,
						allocated = 6,
						logical_volume = volume_name
					} )
				end
				-- Filling snapshots in logical_volumes
				logical_volumes[ volume_name ].snapshots = snapshots
				-- Filling snapshots in logicals
				for _, snapshot in ipairs( snapshots ) do
					logicals[ logical_id ].logical_volumes[ snapshot.name ] = snapshot
				end
			end
			-- Filling logical_volumes in logicals
			for volume_name,_ in pairs( logical_volumes ) do
				logicals[ logical_id ].logical_volumes[ volume_name ] = logical_volumes[ volume_name ]
			end
			-- Filling physicals in logicals
			local physicals = {}
			for i = 1, max_physicals do
				local physical_id = tonumber( l ) .. ":" .. tonumber( i )
				physicals[ physical_id ] = einarc.Physical:new( {
					id = physical_id,
					model = "foobar",
					revision = "foobar",
					serial = "foobar",
					size = 666,
					state = "0"
				} )
			end
			for physical_id,_ in pairs( physicals ) do
				logicals[ logical_id ].physicals[ physical_id ] = logical_id
			end
		end
		-- Cleaning logical
		logicals[ 1 ].logical_volumes = {}

		local got = matrix.filter_highlight_snapshots(
			matrix.filter_alternation_border_colors(
				matrix.filter_borders_highlight( {
					lines = matrix.overall( {
						physicals = physicals,
						logicals = logicals
					} )
				} ),
				colors_array
			)
		)[ "lines" ]

		--print( common.ppt( { got } ) )
		local color = 1 --normal_color
		assertEquals( got[ 1 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 2 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 3 ].logical_volume.highlight.background_color, colors_array[ color ] )

		local color = 2 --light_color
		assertEquals( got[ 4 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 5 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 6 ].logical_volume.highlight.background_color, colors_array[ color ] )

		local color = 1 --normal_color
		assertEquals( got[ 7 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 8 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 9 ].logical_volume.highlight.background_color, colors_array[ color ] )

		local color = 2 --light_color
		assertEquals( got[ 11 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 12 ].logical_volume.highlight.background_color, colors_array[ color ] )
		assertEquals( got[ 13 ].logical_volume.highlight.background_color, colors_array[ color ] )
	end

TestFilterFlashcacheCalculation = {}
	function TestFilterFlashcacheCalculation:test_flashcache_calculation_with_two_normal_logicals()
		local physicals = common.deepcopy( PHYSICALS_DOUBLE )
		local logicals  = common.deepcopy( LOGICALS_DOUBLE )
		-- logical  3 normal
		-- logical 13 normal
		physicals[ "13:4" ].state = "13"
		physicals[ "13:5" ].state = "13"
		logicals[ 13 ].physicals[ "13:4" ] = "13"
		logicals[ 13 ].physicals[ "13:5" ] = "13"
		logicals[ 13 ].state = "normal"

		needed = {
			[ 3 ] = { cacheable = true },
			[ 13 ] = { cacheable = true }
		}

		assert( common.compare_tables(
			matrix.filter_calculate_flashcache( {
				lines = matrix.overall( {
					physicals = physicals,
					logicals  = logicals
				} )
			} )[ "flashcache" ],
			needed
		) )
	end

	function TestFilterFlashcacheCalculation:test_flashcache_calculation_with_other_states_of_logical()
		local physicals = common.deepcopy( PHYSICALS_DOUBLE )
		local logicals  = common.deepcopy( LOGICALS_DOUBLE )
		-- logical  3 normal
		-- logical 13 normal
		physicals[ "13:4" ].state = "13"
		physicals[ "13:5" ].state = "13"
		logicals[ 13 ].physicals[ "13:4" ] = "13"
		logicals[ 13 ].physicals[ "13:5" ] = "13"
		logicals[ 13 ].state = "normal"

		-- if logical state not equal normal
		for _,state in ipairs( einarc.LOGICAL_STATES ) do
			if ( state ~= "normal" ) then
				logicals[ 13 ].state = state

				needed = {
					[ 3 ] = { cacheable = true },
					[ 13 ] = {
						cacheable = false,
						message = 'Array must be in "normal" state'
					}
				}

				assert( common.compare_tables(
					matrix.filter_calculate_flashcache( {
						lines = matrix.overall( {
							physicals = physicals,
							logicals  = logicals
						} )
					} )[ "flashcache" ],
					needed
				) )
			end
		end
	end

	function TestFilterFlashcacheCalculation:test_flashcache_calculation_with_failed_logical()
		local physicals = common.deepcopy( PHYSICALS_DOUBLE )
		local logicals  = common.deepcopy( LOGICALS_DOUBLE )
		-- physical 13:5 failed
		-- physical 13:4 failed
		-- logical     3 normal
		-- logical    13 degraded
		local needed = {
			[ 3 ] = { cacheable = true },
			[ 13 ] = {
				cacheable = false,
				message = 'Array must be in "normal" state'
			}
		}

		assert( common.compare_tables(
			matrix.filter_calculate_flashcache( {
				lines = matrix.overall( {
					physicals = physicals,
					logicals  = logicals
				} )
			} )[ "flashcache" ],
			needed
		) )
	end

	function TestFilterFlashcacheCalculation:test_flashcache_calculation_with_normal_and_cached_logical()
		local physicals = common.deepcopy( PHYSICALS_DOUBLE )
		local logicals  = common.deepcopy( LOGICALS_DOUBLE )
		-- physical 13:5 cached
		-- logical     3 normal
		-- logical    13 cached
		physicals[ "13:4" ].state = "13"
		physicals[ "13:5" ].state = "cache"
		logicals[ 13 ].physicals[ "13:4" ] = "13"
		logicals[ 13 ].physicals[ "13:5" ] = "cache"
		logicals[ 13 ].state = "normal"
		logicals[ 13 ].cached_by = "13:5"

		needed = {
			[ 3 ] = { cacheable = true },
			[ 13 ] = {
				cacheable = false,
				message = "Already cached"
			}
		}

		assert( common.compare_tables(
			matrix.filter_calculate_flashcache( {
				lines = matrix.overall( {
					physicals = physicals,
					logicals  = logicals
				} )
			} )[ "flashcache" ],
			needed
		) )
	end

	function TestFilterFlashcacheCalculation:test_flashcache_calculation_with_other_states_and_cached_logical()
		local physicals = common.deepcopy( PHYSICALS_DOUBLE )
		local logicals  = common.deepcopy( LOGICALS_DOUBLE )
		-- physical 13:5 cached
		-- logical     3 normal
		-- logical    13 cached
		physicals[ "13:4" ].state = "13"
		physicals[ "13:5" ].state = "cache"
		logicals[ 13 ].physicals[ "13:4" ] = "13"
		logicals[ 13 ].physicals[ "13:5" ] = "cache"
		logicals[ 13 ].state = "normal"
		logicals[ 13 ].cached_by = "13:5"

		-- if logical state not equal normal
		for _,state in ipairs( einarc.LOGICAL_STATES ) do
			if ( state ~= "normal" ) then
				logicals[ 13 ].state = state

				needed = {
					[ 3 ] = { cacheable = true },
					[ 13 ] = {
						cacheable = false,
						message = "Already cached"
					}
				}

				assert( common.compare_tables(
					matrix.filter_calculate_flashcache( {
						lines = matrix.overall( {
							physicals = physicals,
							logicals  = logicals
						} )
					} )[ "flashcache" ],
					needed
				) )
			end
		end
	end

LuaUnit:run()
